Ultimate Certified Kubernetes Administrator (CKA) Certification Guide
 - Rajesh Vishnupant Gheware -

CHAPTER 1 Introduction to Kubernetes.
  Benefits of Kubernetes
    Following is the list of a few benefits that Kubernetes offers:
     - Service discovery and load balancing:
       Kubernetes provides a service-level abstraction to expose your application.
       This service abstraction enables decoupling between callers of your application and the application itself
        Ví dụ: 
         một ứng dụng frontend có thể gọi ứng dụng backend thông qua Service URL – một địa chỉ mạng ổn định có thể truy cập từ bất kỳ đâu trong cluster.
         Trong khi các bản sao (replica) của ứng dụng backend có thể chạy trên nhiều node khác nhau hoặc được thay thế bằng bản mới,
         ứng dụng frontend không cần quan tâm bản sao nào sẽ phản hồi. Điều này tương tự như việc ứng dụng truy cập cơ sở dữ liệu thông qua Database URL mà không cần lo lắng về các instance cơ sở dữ liệu bên dưới.

        Ngoài việc cung cấp sự tách biệt giữa bên gọi và bên được gọi,
       Kubernetes Service còn hoạt động như một load balancer.
        Ví dụ: 
         nếu có nhiều bản sao của ứng dụng backend,
         Kubernetes sẽ phân phối request đến một trong các bản sao sẵn có.
         Việc phân phối này thường theo cơ chế round-robin, tuy nhiên có thể tùy chỉnh.
          Người dùng/Client        Load Balancer           Các Backend (Pods)
        |                         |                    |
        | ---- Yêu cầu 1 -------> |                    |
        |                         | --(Chọn Pod A)-->  | --- Pod A
        |                         |                    |
        | <--- Phản hồi 1 --------|                    |
        |                         |                    |
        | ---- Yêu cầu 2 -------> |                    |
        |                         | --(Chọn Pod B)-->  | --- Pod B
        |                         |                    |
        | <--- Phản hồi 2 --------|                    |
        |                         |                    |
        | ---- Yêu cầu 3 -------> |                    |
        |                         | --(Chọn Pod C)-->  | --- Pod C
        |                         |                    |
        | <--- Phản hồi 3 --------|                    |
        |                         |                    |
        | ---- Yêu cầu 4 -------> |                    |
        |                         | --(Chọn Pod A)-->  | --- Pod A (Quay vòng lại)
        |                         |                    |
        | <--- Phản hồi 4 --------|                    |
        |                         |                    |
         Cách làm này giúp hệ thống xử lý hiệu quả các mức tải khác nhau trên ứng dụng backend.
     - Automated rollouts and rollbacks
     - Automated bin packing
     - Self-healing
     - Storage orchestration
       Hầu hết các ứng dụng doanh nghiệp cần có bộ nhớ lưu trữ tạm thời hoặc vĩnh viễn để hoạt động.
       Kubernetes được thiết kế để cung cấp quyền truy cập vào nhiều loại lưu trữ khác nhau thông qua API Volume,
       bất kể việc lưu trữ là cần thiết cho thời gian chạy hiện tại của ứng dụng,
       xuyên suốt nhiều phiên chạy, hay sau khi khởi động lại để duy trì trạng thái ứng dụng.
       Kubernetes cũng được thiết kế để làm việc với nhiều nhà cung cấp 
       lưu trữ bên ngoài như AWS EBS, Azure, Google, Ondat, CephFS, GlusterFS, PortWorx, Cinder, v.v.

     - Secrets and configuration management
       Thông tin nhạy cảm mà ứng dụng cần sử dụng — chẳng hạn như API key — có thể được lưu trữ trong đối tượng Secret do Kubernetes cung cấp.
       Tất cả thông tin lưu trong đối tượng Secret đều được mã hóa bằng base64 bởi Kubernetes.
       Thông tin này có thể được ứng dụng truy cập thông qua biến môi trường (environment variables) hoặc hệ thống file của container.
       Kubernetes cũng cung cấp đối tượng ConfigMap để lưu trữ các đầu vào tại thời điểm chạy, ví dụ như các biến môi trường.
       Điều này mang lại sự linh hoạt khi triển khai ứng dụng trong nhiều môi trường khác nhau như test, pre-prod, prod, v.v.
       Thông tin lưu trong đối tượng ConfigMap sẽ được cung cấp cho ứng dụng tại thời điểm chạy thông qua biến môi trường hoặc hệ thống file của container.
       Kubernetes cũng đảm bảo rằng nếu có bất kỳ thay đổi nào trong đối tượng ConfigMap, thì ứng dụng liên quan sẽ được khởi động lại tự động để phản ánh sự thay đổi đó.
    
  - Kubernetes Architecture:
      Logical View
       Control Plane
         API Controller
         ETCD Database
         Scheduler
         Controller (KCM - Kube Controller Manager)
       Worker Plane
         Kubelet
         Kube-proxy
      Dynamic View (hình POD Creation Sequence Diagram)
       Giải thích Diagram:
        Như bạn có thể thấy trong sơ đồ, khi người dùng yêu cầu tạo một pod,
        Bộ điều khiển API (còn được gọi là API-server) sẽ phản hồi sau khi lưu yêu cầu vào cơ sở dữ liệu ETCD.
        Các Bộ điều khiển (Controllers) liên tục kiểm tra các thay đổi mới trong cụm thông qua máy chủ API,
        trong khi Trình lập lịch (scheduler) theo dõi tất cả các pod chưa được chỉ định node và sẽ gán node ngay khi các điều kiện cần thiết được đáp ứng.
        Khi một pod được chỉ định vào một node, Trình lập lịch thông báo cho máy chủ API, 
        sau đó máy chủ API lưu thông tin mới này vào cơ sở dữ liệu ETCD.
        Trong khi đó, Kubelet nhận thông tin về các pod mới được chỉ định 
        và khởi chạy chúng bằng thời gian chạy container (container runtime) trên các node được gán.
        Kubelet cũng cập nhật điều này lên máy chủ API, 
        sau đó máy chủ API lưu trạng thái mới nhất vào cơ sở dữ liệu ETCD.

[Chat AI]
Các thành phần chính
 User/kubectl: Người dùng khởi tạo yêu cầu tạo Pod.
 API Server: Giao diện phía trước của control plane; tất cả giao tiếp đều đi qua đây và nó chịu trách nhiệm xác thực yêu cầu.
 etcd: Kho lưu trữ key-value nhất quán và có tính sẵn sàng cao cho toàn bộ dữ liệu của cluster.
 Scheduler: Theo dõi các Pod mới chưa được gán node và chọn node tối ưu cho chúng.
 Kubelet: Tác nhân chạy trên mỗi worker node, đảm bảo container trong Pod được khởi chạy.
 Container Runtime (ví dụ: containerd/Docker): Công cụ nền tảng chịu trách nhiệm chạy container.

Trình tự tạo Pod 
  Bước 1: Người dùng gửi Pod Manifest Người dùng (hoặc controller như Deployment) dùng kubectl để gửi Pod manifest (YAML hoặc JSON) đến API Server qua API request.
  Bước 2: API Server xác thực & kiểm tra API Server xác thực người dùng và kiểm tra định dạng manifest.
  Bước 3: API Server lưu vào etcd API Server ghi cấu hình đối tượng Pod vào etcd. Trạng thái Pod ban đầu là Pending và chưa có node được gán.
  Bước 4: Phản hồi đến người dùng API Server gửi xác nhận lại cho người dùng/kubectl rằng Pod đã được tạo.
  Bước 5: Scheduler phát hiện Pod mới Scheduler liên tục theo dõi API Server để tìm Pod chưa có nodeName.
  Bước 6: Scheduler gán Pod vào node Scheduler lọc và ưu tiên node phù hợp dựa trên tài nguyên (CPU, RAM), affinity, taints và tolerations; sau đó gửi “binding” để gán tên node vào trường spec.nodeName của Pod.
  Bước 7: API Server cập nhật etcd API Server cập nhật đối tượng Pod trong etcd với thông tin node đã chọn.
  Bước 8: Kubelet phát hiện Pod được gán Kubelet trên node được chỉ định theo dõi API Server và phát hiện Pod đã được gán cho node của nó.
  Bước 9: Kubelet tạo hạ tầng Pod
     Mạng: Thiết lập namespace mạng cho Pod (gán địa chỉ IP).
     Lưu trữ: Mount các volume cần thiết.
     Khởi tạo: Chạy các init container theo thứ tự.
  Bước 10: Kubelet giao tiếp với Container Runtime Kubelet liên lạc với Container Runtime (containerd, Docker) qua CRI để pull image (nếu chưa có) và khởi chạy container ứng dụng.
  Bước 11: Container Runtime chạy container Container Runtime khởi động các container.
  Bước 12: Kubelet cập nhật API Server (Running) Khi container bắt đầu chạy, Kubelet cập nhật trạng thái Pod trên API Server thành Running.
  Bước 13: API Server cập nhật etcd Trạng thái mới của Pod được lưu vào etcd.
  Bước 14: Kubelet giám sát sức khỏe Kubelet tiếp tục giám sát bằng liveness/readiness probes. Pod được đánh dấu Ready khi tất cả container khỏe mạnh và sẵn sàng nhận traffic.
CHAPTER 2 Installing Kubernetes
    Structure
      In this chapter, we will cover the following topics:
      Basic Tools
      Minikube:
       - One of the easiest ways to set up a local Kubernetes cluster is by using Minikube
       - It works on Linux, MacOS, and Windows.
       - The main highlights of Minikube are its ability to be deployed on VMs, containers, and even on bare-metal.
       - When it comes to deploying on containers, it supports CRI-O, Docker, and containerd.
       - Minikube also supports advanced features such as LoadBalancer, filesystem mounts, FeatureGates, and NetworkPolicy.
      Microk8s
      KIND - Kubernetes INside Docker
      Kubeadm
      OS: Ubuntu 22.04


CHAPTER 3 Workload Objects – Pod, Deploy, StatefulSet


CHAPTER 4 Service and Ingress - Exposing Apps Outside the Cluster
CHAPTER 5 Deploy and Scale - Stateless Apps
CHAPTER 6 Deployment Strategies – RollingUpdate, Recreate
CHAPTER 7 Data Persistence - Local and Cloud
CHAPTER 8 Deploy and Scale - StatefulSet
CHAPTER 9 Configure Apps for Production Deployment
CHAPTER 10 Cluster Database - Backup and Restore
CHAPTER 11 Cluster Upgrade – kubeadm
CHAPTER 12 CoreDNS
CHAPTER 13 Networking - Pod Service and Ingress
CHAPTER 14 Kubernetes CNI
CHAPTER 15 Kubernetes Security
CHAPTER 16 Troubleshooting
CHAPTER 17 Kubernetes Production Essentials
CHAPTER 18 Microservices Observability
CHAPTER 19 Scalable Jenkins on Kubernetes
CHAPTER 20 GitOps using ArgoCD and GitHub
CHAPTER 21 CKA Exam Mastery


